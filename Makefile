# üõ†Ô∏è GoVel Framework - Build Automation Makefile
#
# This Makefile provides comprehensive build automation for the GoVel framework.
# It includes targets for building, testing, linting, security scanning,
# and development workflow automation.
#
# Features:
# - üî® Build automation for all packages
# - üß™ Testing with coverage reporting
# - üîç Code quality and linting
# - üîí Security scanning
# - üì¶ Dependency management
# - üöÄ Release automation
# - üßπ Cleanup and maintenance
#
# Usage:
#   make help          # Show available targets
#   make build         # Build all packages
#   make test          # Run all tests
#   make lint          # Run linting
#   make security      # Run security scans
#
# Author: GoVel Framework Team
# Version: 1.0.0
# License: MIT

# üéØ Default target
.DEFAULT_GOAL := help

# üìã Configuration variables
GO_VERSION := 1.23
GOLANGCI_VERSION := v1.55.2
GOSEC_VERSION := latest
GOVULNCHECK_VERSION := latest

# üìÅ Directory configuration  
PACKAGES_DIR := packages
SCRIPTS_DIR := scripts
BUILD_DIR := build
COVERAGE_DIR := coverage
REPORTS_DIR := reports

# üîç Package discovery
PACKAGES := $(shell find $(PACKAGES_DIR) -name "go.mod" -exec dirname {} \; | sort)
PACKAGE_NAMES := $(notdir $(PACKAGES))

# üé® Colors for output
RED := \033[0;31m
GREEN := \033[0;32m
YELLOW := \033[1;33m
BLUE := \033[0;34m
PURPLE := \033[0;35m
CYAN := \033[0;36m
WHITE := \033[1;37m
BOLD := \033[1m
NC := \033[0m

# üñ•Ô∏è Platform detection
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
	PLATFORM := linux
endif
ifeq ($(UNAME_S),Darwin)
	PLATFORM := darwin
endif
ifeq ($(UNAME_S),CYGWIN*)
	PLATFORM := windows
endif
ifeq ($(UNAME_S),MINGW*)
	PLATFORM := windows
endif

ARCH := $(shell uname -m)
ifeq ($(ARCH),x86_64)
	ARCH := amd64
endif
ifeq ($(ARCH),arm64)
	ARCH := arm64
endif

##@ üìã Help and Information

.PHONY: help
help: ## üìã Show this help message
	@echo "$(BOLD)$(CYAN)üõ†Ô∏è GoVel Framework - Build Automation$(NC)"
	@echo ""
	@echo "$(BOLD)Available targets:$(NC)"
	@awk 'BEGIN {FS = ":.*##"}; /^[a-zA-Z_0-9-]+:.*?##/ { printf "  $(CYAN)%-20s$(NC) %s\n", $$1, $$2 }' $(MAKEFILE_LIST)
	@echo ""
	@echo "$(BOLD)Configuration:$(NC)"
	@echo "  Go Version: $(GREEN)$(GO_VERSION)$(NC)"
	@echo "  Platform: $(GREEN)$(PLATFORM)$(NC)"
	@echo "  Architecture: $(GREEN)$(ARCH)$(NC)"
	@echo "  Packages: $(GREEN)$(words $(PACKAGES))$(NC) found"
	@echo ""

.PHONY: info
info: ## ‚ÑπÔ∏è Show project information
	@echo "$(BOLD)$(BLUE)üìä GoVel Framework Information$(NC)"
	@echo ""
	@echo "$(BOLD)üì¶ Packages:$(NC)"
	@for pkg in $(PACKAGE_NAMES); do \
		echo "  - $$pkg"; \
	done
	@echo ""
	@echo "$(BOLD)üîß Environment:$(NC)"
	@echo "  Go Version: $$(go version 2>/dev/null || echo 'Not installed')"
	@echo "  Make Version: $$(make --version | head -1)"
	@echo "  Platform: $(PLATFORM)/$(ARCH)"
	@echo ""

##@ üèóÔ∏è Building

.PHONY: build
build: ## üî® Build all packages
	@echo "$(BOLD)$(GREEN)üî® Building all packages...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üì¶ Building $$pkg...$(NC)"; \
		cd $$pkg && go build -v ./... && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ All packages built successfully$(NC)"

.PHONY: build-%
build-%: ## üî® Build specific package (e.g., make build-logger)
	@if [ -d "$(PACKAGES_DIR)/$*" ]; then \
		echo "$(CYAN)üî® Building package: $*$(NC)"; \
		cd $(PACKAGES_DIR)/$* && go build -v ./...; \
		echo "$(GREEN)‚úÖ Package $* built successfully$(NC)"; \
	else \
		echo "$(RED)‚ùå Package $* not found$(NC)"; \
		exit 1; \
	fi

.PHONY: clean
clean: ## üßπ Clean build artifacts and caches
	@echo "$(YELLOW)üßπ Cleaning build artifacts...$(NC)"
	@rm -rf $(BUILD_DIR) $(COVERAGE_DIR) $(REPORTS_DIR)
	@go clean -cache -testcache -modcache
	@for pkg in $(PACKAGES); do \
		cd $$pkg && go clean ./... && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Cleanup completed$(NC)"

##@ üß™ Testing

.PHONY: test
test: ## üß™ Run all tests with coverage
	@echo "$(BOLD)$(BLUE)üß™ Running tests with coverage...$(NC)"
	@mkdir -p $(COVERAGE_DIR)
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üß™ Testing $$pkg...$(NC)"; \
		pkg_name=$$(basename $$pkg); \
		cd $$pkg && go test -v -race -coverprofile=../$(COVERAGE_DIR)/$$pkg_name-coverage.out -covermode=atomic ./...; \
		if [ $$? -eq 0 ]; then \
			echo "$(GREEN)‚úÖ Tests passed for $$pkg$(NC)"; \
		else \
			echo "$(RED)‚ùå Tests failed for $$pkg$(NC)"; \
		fi; \
		cd - > /dev/null; \
	done
	@$(MAKE) coverage-merge

.PHONY: test-%
test-%: ## üß™ Test specific package (e.g., make test-logger)
	@if [ -d "$(PACKAGES_DIR)/$*" ]; then \
		echo "$(CYAN)üß™ Testing package: $*$(NC)"; \
		mkdir -p $(COVERAGE_DIR); \
		cd $(PACKAGES_DIR)/$* && go test -v -race -coverprofile=../../$(COVERAGE_DIR)/$*-coverage.out -covermode=atomic ./...; \
		echo "$(GREEN)‚úÖ Tests completed for $*$(NC)"; \
	else \
		echo "$(RED)‚ùå Package $* not found$(NC)"; \
		exit 1; \
	fi

.PHONY: test-quick
test-quick: ## ‚ö° Run tests without coverage (faster)
	@echo "$(BLUE)‚ö° Running quick tests...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üß™ Testing $$pkg...$(NC)"; \
		cd $$pkg && go test -v ./... && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Quick tests completed$(NC)"

.PHONY: test-verbose
test-verbose: ## üìù Run tests with verbose output
	@echo "$(BLUE)üìù Running verbose tests...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üß™ Testing $$pkg...$(NC)"; \
		cd $$pkg && go test -v -race -count=1 ./... && cd - > /dev/null; \
	done

.PHONY: benchmark
benchmark: ## üèÉ Run benchmark tests
	@echo "$(PURPLE)üèÉ Running benchmarks...$(NC)"
	@mkdir -p $(REPORTS_DIR)
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üèÉ Benchmarking $$pkg...$(NC)"; \
		pkg_name=$$(basename $$pkg); \
		cd $$pkg && go test -bench=. -benchmem -run=^$$ ./... > ../$(REPORTS_DIR)/$$pkg_name-benchmark.txt; \
		cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Benchmarks completed$(NC)"

##@ üìä Coverage

.PHONY: coverage-merge
coverage-merge: ## üìä Merge coverage reports
	@echo "$(BLUE)üìä Merging coverage reports...$(NC)"
	@if command -v gocovmerge >/dev/null 2>&1; then \
		gocovmerge $(COVERAGE_DIR)/*-coverage.out > $(COVERAGE_DIR)/merged-coverage.out; \
		echo "$(GREEN)‚úÖ Coverage reports merged$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è gocovmerge not found, installing...$(NC)"; \
		go install github.com/wadey/gocovmerge@latest; \
		gocovmerge $(COVERAGE_DIR)/*-coverage.out > $(COVERAGE_DIR)/merged-coverage.out; \
		echo "$(GREEN)‚úÖ Coverage reports merged$(NC)"; \
	fi

.PHONY: coverage-html
coverage-html: coverage-merge ## üìä Generate HTML coverage report
	@echo "$(BLUE)üìä Generating HTML coverage report...$(NC)"
	@go tool cover -html=$(COVERAGE_DIR)/merged-coverage.out -o $(COVERAGE_DIR)/coverage.html
	@echo "$(GREEN)‚úÖ HTML coverage report generated: $(COVERAGE_DIR)/coverage.html$(NC)"

.PHONY: coverage-report
coverage-report: coverage-merge ## üìä Show coverage summary
	@echo "$(BLUE)üìä Coverage Summary:$(NC)"
	@go tool cover -func=$(COVERAGE_DIR)/merged-coverage.out | tail -1
	@go tool cover -func=$(COVERAGE_DIR)/merged-coverage.out > $(COVERAGE_DIR)/coverage-summary.txt

##@ üîç Code Quality

.PHONY: lint
lint: ## üîç Run linting with golangci-lint
	@echo "$(PURPLE)üîç Running golangci-lint...$(NC)"
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run --config .golangci.yml ./...; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è golangci-lint not found, installing...$(NC)"; \
		curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $$(go env GOPATH)/bin $(GOLANGCI_VERSION); \
		golangci-lint run --config .golangci.yml ./...; \
	fi
	@echo "$(GREEN)‚úÖ Linting completed$(NC)"

.PHONY: lint-fix
lint-fix: ## üîß Run linting with auto-fix
	@echo "$(PURPLE)üîß Running golangci-lint with auto-fix...$(NC)"
	@golangci-lint run --config .golangci.yml --fix ./...
	@echo "$(GREEN)‚úÖ Linting with auto-fix completed$(NC)"

.PHONY: format
format: ## üé® Format code with gofmt and goimports
	@echo "$(CYAN)üé® Formatting code...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üé® Formatting $$pkg...$(NC)"; \
		cd $$pkg && gofmt -s -w . && cd - > /dev/null; \
		cd $$pkg && goimports -w . && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Code formatting completed$(NC)"

.PHONY: vet
vet: ## üîç Run go vet
	@echo "$(PURPLE)üîç Running go vet...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üîç Vetting $$pkg...$(NC)"; \
		cd $$pkg && go vet ./... && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Go vet completed$(NC)"

##@ üîí Security

.PHONY: security
security: security-gosec security-govulncheck ## üîí Run all security scans

.PHONY: security-gosec  
security-gosec: ## üõ°Ô∏è Run gosec security scanner
	@echo "$(RED)üõ°Ô∏è Running gosec security scanner...$(NC)"
	@mkdir -p $(REPORTS_DIR)/security
	@if command -v gosec >/dev/null 2>&1; then \
		for pkg in $(PACKAGES); do \
			echo "$(CYAN)üîç Scanning $$pkg...$(NC)"; \
			pkg_name=$$(basename $$pkg); \
			cd $$pkg && gosec -fmt json -out ../$(REPORTS_DIR)/security/$$pkg_name-gosec.json ./... || true; \
			cd - > /dev/null; \
		done; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è gosec not found, installing...$(NC)"; \
		go install github.com/securecodewarrior/gosec/v2/cmd/gosec@$(GOSEC_VERSION); \
		$(MAKE) security-gosec; \
	fi
	@echo "$(GREEN)‚úÖ gosec scan completed$(NC)"

.PHONY: security-govulncheck
security-govulncheck: ## üîç Run govulncheck vulnerability scanner
	@echo "$(RED)üîç Running govulncheck...$(NC)"
	@if command -v govulncheck >/dev/null 2>&1; then \
		for pkg in $(PACKAGES); do \
			echo "$(CYAN)üîç Checking $$pkg for vulnerabilities...$(NC)"; \
			cd $$pkg && govulncheck ./... && cd - > /dev/null; \
		done; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è govulncheck not found, installing...$(NC)"; \
		go install golang.org/x/vuln/cmd/govulncheck@$(GOVULNCHECK_VERSION); \
		$(MAKE) security-govulncheck; \
	fi
	@echo "$(GREEN)‚úÖ Vulnerability check completed$(NC)"

##@ üì¶ Dependencies

.PHONY: deps-download
deps-download: ## üì• Download dependencies for all packages
	@echo "$(BLUE)üì• Downloading dependencies...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üì• Downloading deps for $$pkg...$(NC)"; \
		cd $$pkg && go mod download && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Dependencies downloaded$(NC)"

.PHONY: deps-tidy
deps-tidy: ## üßπ Tidy dependencies for all packages
	@echo "$(BLUE)üßπ Tidying dependencies...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üßπ Tidying deps for $$pkg...$(NC)"; \
		cd $$pkg && go mod tidy && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Dependencies tidied$(NC)"

.PHONY: deps-verify
deps-verify: ## ‚úÖ Verify dependencies for all packages
	@echo "$(BLUE)‚úÖ Verifying dependencies...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)‚úÖ Verifying deps for $$pkg...$(NC)"; \
		cd $$pkg && go mod verify && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Dependencies verified$(NC)"

.PHONY: deps-update
deps-update: ## üîÑ Update dependencies (patch versions)
	@echo "$(YELLOW)üîÑ Updating dependencies (patch versions)...$(NC)"
	@for pkg in $(PACKAGES); do \
		echo "$(CYAN)üîÑ Updating deps for $$pkg...$(NC)"; \
		cd $$pkg && go get -u=patch ./... && go mod tidy && cd - > /dev/null; \
	done
	@echo "$(GREEN)‚úÖ Dependencies updated$(NC)"

##@ üöÄ Release and Distribution

.PHONY: pre-release
pre-release: clean lint test security ## üöÄ Run all pre-release checks
	@echo "$(BOLD)$(GREEN)üöÄ Pre-release checks completed successfully$(NC)"

.PHONY: check-all
check-all: lint vet test security ## ‚úÖ Run all quality checks
	@echo "$(BOLD)$(GREEN)‚úÖ All quality checks passed$(NC)"

##@ üõ†Ô∏è Development

.PHONY: dev-setup
dev-setup: ## üõ†Ô∏è Set up development environment
	@echo "$(BLUE)üõ†Ô∏è Setting up development environment...$(NC)"
	@echo "$(CYAN)üì• Installing development tools...$(NC)"
	@go install github.com/golangci/golangci-lint/cmd/golangci-lint@$(GOLANGCI_VERSION)
	@go install github.com/securecodewarrior/gosec/v2/cmd/gosec@$(GOSEC_VERSION)
	@go install golang.org/x/vuln/cmd/govulncheck@$(GOVULNCHECK_VERSION)
	@go install github.com/wadey/gocovmerge@latest
	@echo "$(GREEN)‚úÖ Development environment setup completed$(NC)"

.PHONY: dev-reset
dev-reset: clean deps-tidy ## üîÑ Reset development environment
	@echo "$(YELLOW)üîÑ Resetting development environment...$(NC)"
	@$(MAKE) deps-download
	@echo "$(GREEN)‚úÖ Development environment reset$(NC)"

##@ üìä Reporting

.PHONY: report-summary
report-summary: ## üìä Generate comprehensive project summary
	@echo "$(BOLD)$(BLUE)üìä GoVel Framework Summary Report$(NC)"
	@echo ""
	@echo "$(BOLD)üì¶ Packages: $(GREEN)$(words $(PACKAGES))$(NC)"
	@for pkg in $(PACKAGE_NAMES); do \
		lines=$$(find $(PACKAGES_DIR)/$$pkg -name "*.go" -not -path "*/vendor/*" -not -name "*_test.go" | xargs wc -l 2>/dev/null | tail -1 | awk '{print $$1}' || echo "0"); \
		tests=$$(find $(PACKAGES_DIR)/$$pkg -name "*_test.go" | wc -l || echo "0"); \
		echo "  - $(CYAN)$$pkg$(NC): $$lines lines, $$tests test files"; \
	done
	@echo ""
	@total_lines=$$(find $(PACKAGES_DIR) -name "*.go" -not -path "*/vendor/*" -not -name "*_test.go" | xargs wc -l 2>/dev/null | tail -1 | awk '{print $$1}' || echo "0"); \
	total_tests=$$(find $(PACKAGES_DIR) -name "*_test.go" | wc -l || echo "0"); \
	echo "$(BOLD)üìà Total: $(GREEN)$$total_lines$(NC) lines of code, $(GREEN)$$total_tests$(NC) test files"

##@ üéØ Convenience Targets

.PHONY: all
all: clean build test lint security ## üéØ Run complete build pipeline
	@echo "$(BOLD)$(GREEN)üéâ Complete build pipeline finished successfully$(NC)"

.PHONY: quick
quick: build test-quick ## ‚ö° Quick build and test
	@echo "$(BOLD)$(GREEN)‚ö° Quick pipeline completed$(NC)"

# üìù Phony target declaration
.PHONY: help info build clean test coverage lint format vet security deps-download deps-tidy deps-verify deps-update pre-release check-all dev-setup dev-reset report-summary all quick

